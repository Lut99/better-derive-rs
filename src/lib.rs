//  LIB.rs
//    by Lut99
//
//  Created:
//    26 Dec 2024, 11:47:57
//  Last edited:
//    04 Feb 2025, 16:39:07
//  Auto updated?
//    Yes
//
//  Description:
//!   A small Rust crate that provides alternatives for Rust's builtin `Clone`-, `Copy`-, `Debug`-,
//!   `Eq`-, `Hash`- and `PartialEq`-derive macros that apply more accurate trait bounds for generated
//!   impls.
//!   
//!   
//!   # Installation
//!   To use the crate, simply add it to your `Cargo.toml`:
//!   ```toml
//!   better-derive = { git = "https://github.com/Lut99/better-derive-rs" }
//!   ```
//!   
//!   You can also use a specific version by adding the appropriate tag:
//!   ```toml
//!   better-derive = { git = "https://github.com/Lut99/better-derive-rs", tag = "v1.1.0" }
//!   ```
//!   
//!   
//!   # Usage
//!   This crate is supposed to be a drop-in replacement of the builtin macro counterparts.
//!   
//!   The only difference are the generic bounds generated by the macro: instead of generating an e.g.
//!   `Debug`-bound on all _generics_, it generates it for all _fields types_.
//!   
//!   For example:
//!   ```ignore
//!   use std::fmt::{Debug, Formatter, Result as FResult};
//!   use std::marker::PhantomData;
//!   
//!   struct Foo<T>(PhantomData<T>);
//!   
//!   // Generated by the builtin
//!   impl<T> Debug for Foo<T>
//!   where
//!       T: Debug,
//!   {
//!       fn fmt(&self, f: &mut Formatter) -> FResult { /* ... */ }
//!   }
//!   
//!   // Generated by our macro
//!   impl<T> Debug for Foo<T>
//!   where
//!       PhantomData<T>: Debug,
//!   {
//!       fn fmt(&self, f: &mut Formatter) -> FResult { /* ... */ }
//!   }
//!   ```
//!   Since `PhantomData` implements `Debug` regardless of whether `T` does, this means that this
//!   property holds for `Foo` as well.
//!   
//!   ## Supported macros
//!   The following macros find a counterpart in this crate:
//!   - `Clone`
//!   - `Copy`
//!   - `Debug`
//!   - `Eq`
//!   - `Hash`
//!   - `PartialEq`
//!   
//!   ## Documentation
//!   The auto-generated code documentation can be generated by running:
//!   ```sh
//!   cargo doc --no-deps --open
//!   ```
//!   This will automatically open the resulting web pages with your default browser.
//!   
//!   ## Examples
//!   For more examples, see the `examples/`-folder in the main repository.
//!   
//!   
//!   # Contributing
//!   Contributions are welcome! Feel free to
//!   [raise an issue](https://github.com/Lut99/better-derive-rs/issues) or
//!   [create a pull request](https://github.com/Lut99/better-derive-rs/pulls).
//!   
//!   
//!   # License
//!   This project is licensed under the Apache 2.0 license. See `LICENSE/` in the repository for more
//!   details.
//

// Modules
mod clone;
mod copy;
mod debug;
mod eq;
mod extract;
mod hash;
mod partial_eq;

// Imports
use proc_macro::TokenStream;


/***** MACROS *****/
/// Defines a [`Clone`](::std::Clone)-like derive macro that's more lenient to generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Clone`](std::clone::Clone). This is, however, too strict. Instead, all that's needed is that
/// the _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::Clone;
///
/// struct ClonelessType;
///
/// #[derive(Clone)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// let p = PhantomStruct { _t: PhantomData::<&mut ()> }.clone();
/// ```
#[inline]
#[proc_macro_derive(Clone)]
pub fn clone(input: TokenStream) -> TokenStream { clone::clone(input) }

/// Defines a [`Copy`](::std::Copy)-like derive macro that's more lenient to generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Copy`](std::marker::Copy). This is, however, too strict. Instead, all that's needed is that
/// the _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::{Clone, Copy};
///
/// struct CopylessType;
///
/// #[derive(Clone, Copy)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// let p = PhantomStruct { _t: PhantomData::<&mut ()> };
/// let q = p;
/// let r = p;
/// ```
#[inline]
#[proc_macro_derive(Copy)]
pub fn copy(input: TokenStream) -> TokenStream { copy::copy(input) }

/// Defines a [`Debug`](::std::Debug)-like derive macro that's more lenient to generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Debug`](std::fmt::Debug). This is, however, too strict. Instead, all that's needed is that
/// the _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::Debug;
///
/// struct DebuglessType;
///
/// #[derive(Debug)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// assert_eq!(
///     format!("{:?}", PhantomStruct::<DebuglessType> { _t: PhantomData }),
///     "PhantomStruct { _t: \
///      PhantomData<rust_out::main::_doctest_main_src_lib_rs_110_0::DebuglessType> }"
/// )
/// ```
#[inline]
#[proc_macro_derive(Debug)]
pub fn debug(input: TokenStream) -> TokenStream { debug::debug(input) }

/// Defines an [`Eq`](::std::Eq)-like derive macro that's more lenient to generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Eq`](std::cmp::Eq). This is, however, too strict. Instead, all that's needed is that the
/// _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::{Eq, PartialEq};
///
/// struct EqlessType;
///
/// #[derive(Eq, PartialEq)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// assert!(
///     PhantomStruct::<EqlessType> { _t: PhantomData }
///         == PhantomStruct::<EqlessType> { _t: PhantomData }
/// );
/// ```
#[inline]
#[proc_macro_derive(Eq)]
pub fn eq(input: TokenStream) -> TokenStream { eq::eq(input) }

/// Defines a [`Hash`](::std::Hash)-like derive macro that's more lenient to generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Hash`](std::cmp::Hash). This is, however, too strict. Instead, all that's needed is
/// that the _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Examples
/// ```rust
/// use std::hash::{DefaultHasher, Hash as _, Hasher as _};
/// use std::marker::PhantomData;
///
/// use better_derive::Hash;
///
/// struct HashlessType;
///
/// #[derive(Hash)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// assert_eq!(
///     {
///         let mut state = DefaultHasher::default();
///         PhantomStruct::<HashlessType> { _t: PhantomData }.hash(&mut state);
///         state.finish()
///     },
///     15130871412783076140
/// );
/// ```
#[inline]
#[proc_macro_derive(Hash)]
pub fn hash(input: TokenStream) -> TokenStream { hash::hash(input) }

/// Defines a [`PartialEq`](::std::PartialEq)-like derive macro that's more lenient to generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`PartialEq`](std::cmp::PartialEq). This is, however, too strict. Instead, all that's needed is
/// that the _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::PartialEq;
///
/// struct PartialEqlessType;
///
/// #[derive(PartialEq)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// assert!(
///     PhantomStruct::<PartialEqlessType> { _t: PhantomData }
///         == PhantomStruct::<PartialEqlessType> { _t: PhantomData }
/// );
/// ```
#[inline]
#[proc_macro_derive(PartialEq)]
pub fn partial_eq(input: TokenStream) -> TokenStream { partial_eq::partial_eq(input) }
