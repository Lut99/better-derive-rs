//  LIB.rs
//    by Lut99
//
//  Created:
//    26 Dec 2024, 11:47:57
//  Last edited:
//    13 Feb 2025, 15:37:22
//  Auto updated?
//    Yes
//
//  Description:
//!   A small Rust crate that provides alternatives for Rust's builtin `Clone`-, `Copy`-, `Debug`-,
//!   `Eq`-, `Hash`-, `Ord`-, `PartialEq`- and `PartialOrd`-derive macros that apply more accurate trait
//!   bounds for generated impls.
//!
//!
//!   # Installation
//!   To use the crate, simply add it to your `Cargo.toml`:
//!   ```toml
//!   better-derive = { git = "https://github.com/Lut99/better-derive-rs" }
//!   ```
//!
//!   You can also use a specific version by adding the appropriate tag:
//!   ```toml
//!   better-derive = { git = "https://github.com/Lut99/better-derive-rs", tag = "v1.5.0" }
//!   ```
//!
//!
//!   # Usage
//!   This crate is supposed to be a drop-in replacement of the builtin macro counterparts.
//!
//!   The only difference are the generic bounds generated by the macro: instead of generating an e.g.
//!   `Debug`-bound on all _generics_, it generates it for all _fields types_.
//!
//!   For example:
//!   ```ignore
//!   use std::fmt::{Debug, Formatter, Result as FResult};
//!   use std::marker::PhantomData;
//!
//!   struct Foo<T>(PhantomData<T>);
//!
//!   // Generated by the builtin
//!   impl<T> Debug for Foo<T>
//!   where
//!       T: Debug,
//!   {
//!       fn fmt(&self, f: &mut Formatter) -> FResult { /* ... */ }
//!   }
//!
//!   // Generated by our macro
//!   impl<T> Debug for Foo<T>
//!   where
//!       PhantomData<T>: Debug,
//!   {
//!       fn fmt(&self, f: &mut Formatter) -> FResult { /* ... */ }
//!   }
//!   ```
//!   Since `PhantomData` implements `Debug` regardless of whether `T` does, this means that this
//!   property holds for `Foo` as well.
//!
//!   ## Supported macros
//!   The following macros find a counterpart in this crate:
//!   - `Clone`
//!   - `Copy`
//!   - `Debug`
//!   - `Eq`
//!   - `Hash`
//!   - `Ord`
//!   - `PartialEq`
//!   - `PartialOrd`
//!
//!   There are also some macros for other crates, unlocked by feature:
//!   - [_serde_](https://serde.rs):
//!     - `Serialize`
//!
//!   ## All macros: Defining bounds
//!   By default, the generated impls generate bounds of the shape for e.g. `Clone` as follows:
//!   ```plain
//!   TYPE: Clone,
//!   ```
//!   for every type `TYPE` somehow a field of your base object (directly or in a variant) that depends
//!   on a generic. If this doesn't suit your needs, you can define your own bounds using the
//!   `#[better_derive(bound(...))]`-attribute (or the macro-specific attribute, e.g.,
//!   `#[clone(bound(...))]`.
//!
//!   It has the following syntax:
//!   ```ignore
//!   #[better_derive(bound(<GEN> where CLAUSES))]
//!   ```
//!   where `GEN` is defining the generic parameters, and `CLAUSES` a list of where-clause to constrain
//!   them. You can use `r#trait` as an alias for the trait currently being derived.
//!
//!   For example:
//!   ```ignore
//!   use std::marker::PhantomData;
//!   use better_derive::Clone;
//!
//!   // This emulates the standard behaviour
//!   #[derive(Clone)]
//!   #[clone(bound(<T> where T: Clone))]
//!   // Equivalent to the attribute above, but for all the crate macros
//!   #[better_derive(bound(<T> where T: r#trait))]
//!   struct Foo<T> {
//!       foo: PhantomData<T>,
//!   }
//!   ```
//!   See the [`custom.rs`](./examples/custom.rs)-example in the repository.
//!
//!   ## `Debug`, `Hash`, `PartialEq`, `PartialOrd` and `Serialize`: Skipping fields
//!   The `Debug`-, `Hash`-, `PartialEq`-, `PartialOrd`- and `Serialize` derive macros have some
//!   additional functionality: you can optionally ignore fields in the generated implementation.
//!   Specifically, you can annotate fields with `#[debug(skip)]`, `#[hash(skip)]`,
//!   `#[partial_eq(skip)]` and/or `#[serialize(skip)]`, respectively, to have it omitted.
//!
//!   See the respective macro's docs for more information, or see the [`skip.rs`](./examples/skip.rs)-
//!   example in the repository.
//!
//!   ## Features
//!   This crate supports the following features:
//!   - `serde`: Unlock the `Serialize`-macro.
//!     - Note that the generated impls will depend on _your own_ serde dependency. You may get some funky errors if you forget to include it, so always do that first.
//!
//!   ## Documentation
//!   The auto-generated code documentation can be generated by running:
//!   ```sh
//!   cargo doc --no-deps --open
//!   ```
//!   This will automatically open the resulting web pages with your default browser.
//!
//!   ## Examples
//!   For more examples, see the `examples/`-folder in the main repository.
//!
//!
//!   # Contributing
//!   Contributions are welcome! Feel free to
//!   [raise an issue](https://github.com/Lut99/better-derive-rs/issues) or
//!   [create a pull request](https://github.com/Lut99/better-derive-rs/pulls).
//!
//!
//!   # License
//!   This project is licensed under the Apache 2.0 license. See `LICENSE/` in the repository for more
//!   details.
//

// Modules
mod clone;
mod common;
mod copy;
mod debug;
mod eq;
mod hash;
mod ord;
mod partial_eq;
mod partial_ord;
mod serialize;

// Imports
use proc_macro::TokenStream;


/***** STANDARD LIB *****/
/// Defines a [`Clone`](derive@::std::clone::Clone)-like derive macro that's more lenient to
/// generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Clone`](std::clone::Clone). This is, however, too strict. Instead, all that's needed is that
/// the _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::Clone;
///
/// struct ClonelessType;
///
/// #[derive(Clone)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// let p = PhantomStruct { _t: PhantomData::<&mut ()> }.clone();
/// ```
#[inline]
#[proc_macro_derive(Clone, attributes(better_derive, clone))]
pub fn clone(input: TokenStream) -> TokenStream { clone::clone(input) }

/// Defines a [`Copy`](derive@::std::marker::Copy)-like derive macro that's more lenient to
/// generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Copy`](std::marker::Copy). This is, however, too strict. Instead, all that's needed is that
/// the _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::{Clone, Copy};
///
/// struct CopylessType;
///
/// #[derive(Clone, Copy)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// let p = PhantomStruct { _t: PhantomData::<&mut ()> };
/// let q = p;
/// let r = p;
/// ```
#[inline]
#[proc_macro_derive(Copy, attributes(better_derive, copy))]
pub fn copy(input: TokenStream) -> TokenStream { copy::copy(input) }

/// Defines a [`Debug`](derive@::std::fmt::Debug)-like derive macro that's more lenient to
/// generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Debug`](std::fmt::Debug). This is, however, too strict. Instead, all that's needed is that
/// the _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
///
/// # Skipping fields
/// You can optionally omit fields from the generated implementation with the `#[debug(skip)]`-
/// attribute:
/// ```rust
/// use better_derive::Debug;
///
/// #[derive(Debug)]
/// struct Foo {
///     // Something very interesting we want to debug
///     cool_field:   String,
///     // Something very boring we don't care about
///     #[debug(skip)]
///     boring_field: (),
/// }
/// ```
/// Importantly, adding the skip-attribute **also removes that field's type from the trait
/// bounds**. If the field has a tricky type to implement `Debug` for, you can simply not do it by
/// using this attribute.
///
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::Debug;
///
/// struct DebuglessType;
///
/// #[derive(Debug)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// assert_eq!(
///     format!("{:?}", PhantomStruct::<DebuglessType> { _t: PhantomData }),
///     "PhantomStruct { _t: \
///      PhantomData<rust_out::main::_doctest_main_src_lib_rs_251_0::DebuglessType> }"
/// )
/// ```
#[inline]
#[proc_macro_derive(Debug, attributes(better_derive, debug))]
pub fn debug(input: TokenStream) -> TokenStream { debug::debug(input) }

/// Defines an [`Eq`](derive@::std::cmp::Eq)-like derive macro that's more lenient to generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Eq`](std::cmp::Eq). This is, however, too strict. Instead, all that's needed is that the
/// _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::{Eq, PartialEq};
///
/// struct EqlessType;
///
/// #[derive(Eq, PartialEq)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// assert!(
///     PhantomStruct::<EqlessType> { _t: PhantomData }
///         == PhantomStruct::<EqlessType> { _t: PhantomData }
/// );
/// ```
#[inline]
#[proc_macro_derive(Eq, attributes(better_derive, eq))]
pub fn eq(input: TokenStream) -> TokenStream { eq::eq(input) }

/// Defines a [`Hash`](derive@::std::hash::Hash)-like derive macro that's more lenient to generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Hash`](std::cmp::Hash). This is, however, too strict. Instead, all that's needed is
/// that the _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
///
/// # Skipping fields
/// You can optionally omit fields from the generated implementation with the `#[hash(skip)]`-
/// attribute:
/// ```rust
/// use better_derive::Hash;
///
/// #[derive(Hash)]
/// struct Foo {
///     // Something very interesting we want to hash
///     dynamic_field: String,
///     // Something very boring that never changes anyway
///     #[hash(skip)]
///     static_field:  (),
/// }
/// ```
/// Importantly, adding the skip-attribute **also removes that field's type from the trait
/// bounds**. If the field has a tricky type to implement `Hash` for, or is very expensive to hash
/// but will never vary between two instances, you can simply not do it by using this attribute.
///
///
/// # Examples
/// ```rust
/// use std::hash::{DefaultHasher, Hash as _, Hasher as _};
/// use std::marker::PhantomData;
///
/// use better_derive::Hash;
///
/// struct HashlessType;
///
/// #[derive(Hash)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// assert_eq!(
///     {
///         let mut state = DefaultHasher::default();
///         PhantomStruct::<HashlessType> { _t: PhantomData }.hash(&mut state);
///         state.finish()
///     },
///     15130871412783076140
/// );
/// ```
#[inline]
#[proc_macro_derive(Hash, attributes(better_derive, hash))]
pub fn hash(input: TokenStream) -> TokenStream { hash::hash(input) }

/// Defines an [`Ord`](derive@::std::cmp::Ord)-like derive macro that's more lenient to generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Ord`](std::cmp::Ord). This is, however, too strict. Instead, all that's needed is that the
/// _fields_ implement it, which may or may not require the generics to do so.
///
/// This macro will generate an implementation with the bounds described as above, but that will
/// otherwise refer to the implementation of [`PartialOrd`](std::cmp::PartialOrd). As such, if
/// you're deriving it, it is recommended to use [our derive macro](derive@PartialOrd) as well.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Skipping fields
/// You can optionally omit fields from the generated implementation with the
/// `#[ord(skip)]`-attribute:
/// ```rust
/// use better_derive::{Eq, Ord, PartialEq, PartialOrd};
///
/// #[derive(Ord, PartialEq, Eq, PartialOrd)]
/// struct Foo {
///     // Something very interesting we want to compare
///     dynamic_field: String,
///     // Something very boring that never changes anyway
///     #[ord(skip)]
///     static_field:  (),
/// }
/// ```
/// Importantly, adding the skip-attribute **also removes that field's type from the trait
/// bounds**. If the field has a tricky type to implement `Ord` for, or is very expensive to
/// compare but will never vary between two instances, you can simply not do it by using this
/// attribute.
///
///
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::{Eq, Ord, PartialEq, PartialOrd};
///
/// struct OrdlessType;
///
/// #[derive(PartialEq, Ord, Eq, PartialOrd)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// assert!(
///     !(PhantomStruct::<OrdlessType> { _t: PhantomData }
///         > PhantomStruct::<OrdlessType> { _t: PhantomData })
/// );
/// ```
#[inline]
#[proc_macro_derive(Ord, attributes(better_derive, ord))]
pub fn ord(input: TokenStream) -> TokenStream { ord::ord(input) }

/// Defines a [`PartialEq`](derive@::std::cmp::PartialEq)-like derive macro that's more lenient to
/// generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`PartialEq`](std::cmp::PartialEq). This is, however, too strict. Instead, all that's needed is
/// that the _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Skipping fields
/// You can optionally omit fields from the generated implementation with the
/// `#[partial_eq(skip)]`-attribute:
/// ```rust
/// use better_derive::PartialEq;
///
/// #[derive(PartialEq)]
/// struct Foo {
///     // Something very interesting we want to compare
///     dynamic_field: String,
///     // Something very boring that never changes anyway
///     #[partial_eq(skip)]
///     static_field:  (),
/// }
/// ```
/// Importantly, adding the skip-attribute **also removes that field's type from the trait
/// bounds**. If the field has a tricky type to implement `PartialEq` for, or is very expensive to
/// compare but will never vary between two instances, you can simply not do it by using this
/// attribute.
///
///
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::PartialEq;
///
/// struct PartialEqlessType;
///
/// #[derive(PartialEq)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// assert!(
///     PhantomStruct::<PartialEqlessType> { _t: PhantomData }
///         == PhantomStruct::<PartialEqlessType> { _t: PhantomData }
/// );
/// ```
#[inline]
#[proc_macro_derive(PartialEq, attributes(better_derive, partial_eq))]
pub fn partial_eq(input: TokenStream) -> TokenStream { partial_eq::partial_eq(input) }

/// Defines a [`PartialOrd`](derive@::std::cmp::PartialOrd)-like derive macro that's more lenient
/// to generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`PartialOrd`](std::cmp::PartialOrd). This is, however, too strict. Instead, all that's needed
/// is that the _fields_ implement it, which may or may not require the generics to do so.
///
/// You can use this macro in exactly the same way as the builtin one.
///
/// # Skipping fields
/// You can optionally omit fields from the generated implementation with the
/// `#[partial_ord(skip)]`-attribute:
/// ```rust
/// use better_derive::{PartialEq, PartialOrd};
///
/// #[derive(PartialEq, PartialOrd)]
/// struct Foo {
///     // Something very interesting we want to compare
///     dynamic_field: String,
///     // Something very boring that never changes anyway
///     #[partial_ord(skip)]
///     static_field:  (),
/// }
/// ```
/// Importantly, adding the skip-attribute **also removes that field's type from the trait
/// bounds**. If the field has a tricky type to implement `PartialOrd` for, or is very expensive to
/// compare but will never vary between two instances, you can simply not do it by using this
/// attribute.
///
///
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::{PartialEq, PartialOrd};
///
/// struct PartialOrdlessType;
///
/// #[derive(PartialEq, PartialOrd)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// assert!(
///     !(PhantomStruct::<PartialOrdlessType> { _t: PhantomData }
///         > PhantomStruct::<PartialOrdlessType> { _t: PhantomData })
/// );
/// ```
#[inline]
#[proc_macro_derive(PartialOrd, attributes(better_derive, partial_ord))]
pub fn partial_ord(input: TokenStream) -> TokenStream { partial_ord::partial_ord(input) }





/***** SERDE *****/
/// Defines a [`Serialize`](https://serde.rs/derive.html)-like derive macro that's more lenient to
/// generics.
///
/// In particular, the default derive macro enforces that all _generics_ implement
/// [`Serialize`](https://docs.rs/serde/1.0.219/serde/trait.Serialize.html). This is, however, too
/// strict. Instead, all that's needed is that the _fields_ implement it, which may or may not
/// require the generics to do so.
///
/// You can use this macro in exactly the same way as the original one.
///
/// # Examples
/// ```rust
/// use std::marker::PhantomData;
///
/// use better_derive::Serialize;
///
/// struct SerializelessType;
///
/// #[derive(Serialize)]
/// struct PhantomStruct<T> {
///     _t: PhantomData<T>,
/// }
///
/// let p = serde_json::to_string(&PhantomStruct { _t: PhantomData::<SerializelessType> }).unwrap();
/// ```
#[inline]
#[proc_macro_derive(Serialize, attributes(better_derive, serialize))]
pub fn serialize(input: TokenStream) -> TokenStream { serialize::serialize(input) }
